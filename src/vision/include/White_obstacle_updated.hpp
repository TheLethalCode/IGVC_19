#ifndef REMOVE_OBSTACLES#define REMOVE_OBSTACLES#include <bits/stdc++.h>#include "opencv2/highgui/highgui.hpp"#include "opencv2/imgproc/imgproc.hpp"#include "opencv2/core/core.hpp"using namespace std;using namespace cv;Mat joiner_of_white_spaces_in_obstacles(Mat img) {  int max = 120;  for (int j = 0; j < img.cols ;j++) {    int flag = 0;    int count = 0;    int index = 0;    for (int i = 0; i < img.rows-1; i++) {      if (flag == 1 && img.at<uchar>(i,j) == 0) {        count++;      }      if (flag == 1 && img.at<uchar>(i,j) == 255) {        if (count < max) {          for (int i = index; i < index+count; i++) {            img.at<uchar>(i,j) = 255;          }        }        flag = 0;        count = 0;      }      //black      if (img.at<uchar>(i,j) == 255 && img.at<uchar>(i+1, j) == 0) {        index = i;        flag = 1;      }    }  }  return img;}Mat remove_white_obstacles(Mat output, Mat img) {  for(int  i = 0; i < img.rows; i++)  {    for (int j = 0; j < img.cols; j++)    {      int count = 0, n, check = 0;      // if(i<img.rows/4)      //   n = 10;      // else if(i>=img.rows/5 && i < img.rows*2/5)      //   n = 25;      // else if(i>=img.rows*2/5 && i < img.rows*3/5)      //   n = 40;      // else if(i>=img.rows*3/4)      //   n = 50;      if(i<img.rows/4)        n = 20;      else if(i>=img.rows/5 && i < img.rows*2/5)        n = 35;      else if(i>=img.rows*2/5 && i < img.rows*3/5)        n = 55;      else if(i>=img.rows*3/4)        n = 70;      //n = (10 + ((50*(i+1))/img.rows));      if ((abs(img.at<Vec3b>(i, j)[0] - img.at<Vec3b>(i, j)[1]) < img.at<Vec3b>(i, j)[0]*0.2 && abs(img.at<Vec3b>(i, j)[1] - img.at<Vec3b>(i, j)[2]) < img.at<Vec3b>(i, j)[1]*0.2 && abs(img.at<Vec3b>(i, j)[2] - img.at<Vec3b>(i, j)[0]) < img.at<Vec3b>(i, j)[2]*0.2) ||          img.at<Vec3b>(i, j)[0] > 150 && img.at<Vec3b>(i, j)[1] > 150 && img.at<Vec3b>(i, j)[2]>150)      {        check = 1;        for(int k = (-1)*(n/2); k < (n/2)+1; k++)        {          for(int l = (-1)*(n/2); l < (n/2)+1; l++)          {            if(i+k >=0 && i+k < img.rows && j+l >=0 && j+l <img.cols)            {              if(img.at<Vec3b>(i+k, j+l)[0] < img.at<Vec3b>(i+k, j+l)[1]*2/3 && img.at<Vec3b>(i+k, j+l)[2] < 1.3*img.at<Vec3b>(i+k, j+l)[1] && img.at<Vec3b>(i+k, j+l)[2] > 0.7*img.at<Vec3b>(i+k, j+l)[1])                count++;                if(count > n/3)                  l = n;                  k = n;            }          }        }      }      if (count < n/3 && check == 1)      {        output.at<uchar>(i, j) = 255;      }      else        {        output.at<uchar>(i, j) = 0;      }      count = 0;    }  }  return output;}Mat remove_obstacles(Mat img, vector<Point> obs_lidar) {  //obstacles.clear();  Mat chan[3];  Mat Simg7(img.rows, img.cols, CV_8UC1, Scalar(255));  split(img, chan);  chan[0] = chan[0] - 70*(Simg7-chan[0])/255;  chan[1] = chan[1] + 30*(chan[1])/255;  merge(chan, 3, img);  Mat channels[3];  Mat channels_w[3];  Mat dark_obs;  Mat white_obs;  Mat bright_obs(img.rows, img.cols, CV_8UC1, Scalar(0));	vector<vector<Point> > contours_bright;	vector<Vec4i> hierarchy_bright;	vector<vector<Point> > contours_dark;	vector<Vec4i> hierarchy_dark;	vector<vector<Point> > contours_w;	vector<Vec4i> hierarchy_w;  /*  for bright red and blue obstacles   */  split(img, channels);  bright_obs = channels[2] - channels[1];  dark_obs = channels[0] - channels[1];  medianBlur(bright_obs, bright_obs, 9);  /*  thresholding    */  threshold(bright_obs, bright_obs, 50, 255, THRESH_BINARY);  threshold(dark_obs, dark_obs, 50, 255, THRESH_BINARY);  threshold(channels_w[1], white_obs, 200, 255, THRESH_BINARY);  /*  morphology operations   */  dilate(bright_obs, bright_obs, Mat(), Point(-1,-1), 7);  for(int i = 0; i < img.rows; i++)  {  	for(int j = 0; j < img.cols; j++)  	{  		if(img.at<Vec3b>(i, j)[0] < img.at<Vec3b>(i, j)[2]/2 && img.at<Vec3b>(i, j)[1] < img.at<Vec3b>(i, j)[2]/1.5)  		{  			bright_obs.at<uchar>(i, j) = 255;  		}  	}  }  // namedWindow("bright_obs", 0);  // imshow("bright_obs", bright_obs);  dilate(dark_obs, dark_obs, Mat(), Point(-1,-1), 4);    /*  joiner function joins the white spaces between detected obstacles   */  bright_obs = joiner_of_white_spaces_in_obstacles(bright_obs);  /*  finding contours    */  findContours(bright_obs, contours_bright, hierarchy_bright, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);  findContours(dark_obs, contours_dark, hierarchy_dark, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);    /*  storing bounding boxes  */  vector<Rect> box_bright(contours_bright.size());  vector<Rect> box_dark(contours_dark.size());    /*  bright red  */  for (int i = 0; i < contours_bright.size(); i++) {    box_bright[i] =  boundingRect(contours_bright[i]);    if (box_bright[i].area() > 200) {    	drawContours(img, contours_bright, i, Scalar(0, 0, 0), -1, 8, hierarchy_bright);    }}  /*  bright blue *///   for (int i = 0; i < contours_dark.size(); i++) {//     box_dark[i] =  boundingRect(contours_dark[i]);//     if (box_dark[i].area() > 8000) {//     	for(int  k = box_dark[i].tl().x; k < box_dark[i].br().x; k++)//     	{//     		for (int l = box_dark[i].tl().y; l < box_dark[i].br().y; l++)//     		{//     			img.at<Vec3b>(l, k) = {0, 0,0};//     		}//     	}// 	}// }Mat wobs(img.rows, img.cols, CV_8UC1, Scalar(0));wobs = remove_white_obstacles(wobs, img);erode(wobs, wobs, Mat(), Point(-1, -1), 5);findContours(wobs, contours_w, hierarchy_w, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);vector<Rect> box_w(contours_w.size());//cout << contours_w.size() << endl;for (int i = 0; i < contours_w.size(); i++) {    box_w[i] =  boundingRect(contours_w[i]);    // cout << box_w[i].area() << endl;    if (box_w[i].area() > 200) {    	for(int  k = box_w[i].tl().x - 15; k < box_w[i].br().x + 15; k++)    	{    		for (int l = box_w[i].tl().y -15; l < box_w[i].br().y + 15; l++)    		{    			if(k < img.cols && k > -1 && l < img.rows && l > -1)    				img.at<Vec3b>(l, k) = {0, 0, 0};    		}    	}    }}// for (int i = 0; i < contours_bright.size(); i++) {// cout << contours_bright[i];// }return img;		}#endif